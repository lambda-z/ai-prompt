{
  "README.md": "# LangGraph Package Generator\n\n该工程使用 **LangGraph** 把「Prompt → 结构化 JSON 脚本 → 校验 → 执行（生成文件）」串成可控的状态机。\n\n它会让 LLM 输出一个 JSON 对象：key 为文件路径，value 为文件内容字符串，然后在本地生成一个可 `pip install .` 安装、可放入 git 仓库并支持 `pip install git+...` 安装的 Python package（示例为 `greet_package`）。\n\n---\n\n## 目录结构（本仓库）\n\n```\nlanggraph-package-generator/\n  pyproject.toml\n  .env.example\n  app/\n    main.py\n  generator/\n    __init__.py\n    config.py\n    prompts.py\n    schema.py\n    graph.py\n    state.py\n    nodes/\n      __init__.py\n      planner.py\n      validator.py\n      executor.py\n      finalizer.py\n    runtime/\n      __init__.py\n      fs.py\n      sanitize.py\n  tests/\n    test_validator.py\n```\n\n---\n\n## 安装\n\n```bash\npython -m venv .venv\nsource .venv/bin/activate\npip install -U pip\npip install -e .\n```\n\n配置环境变量：\n\n```bash\ncp .env.example .env\n# 填写 OPENAI_API_KEY\n```\n\n---\n\n## 运行（生成一个示例 package 到 ./out/）\n\n```bash\npython -m app.main --out ./out --name greet_package\n```\n\n你也可以传入自定义需求（会被注入到 Prompt 的 {user_input}）：\n\n```bash\npython -m app.main --out ./out --name greet_package --request \"做一个最小包，函数 greet(name) 返回 Hello, name!\"\n```\n\n生成完成后：\n\n```bash\ncd out/greet_package\npip install .\npytest -q\n```\n\n---\n\n## 说明\n\n- Planner：使用你提供的 XML Prompt 模板（做了必要的占位符替换），强制 LLM 只输出 JSON。\n- Validator：对 LLM 输出做 JSON 解析 + Pydantic 校验 + 基本安全检查。\n- Executor：把 JSON 中的文件写入磁盘，形成可安装 package。\n- Finalizer：返回汇总信息（生成路径、文件数、错误等）。\n",
  ".env.example": "OPENAI_API_KEY=your_key_here\nOPENAI_MODEL=gpt-4.1-mini\nMAX_PLAN_REVISIONS=3\n",
  "pyproject.toml": "[project]\nname = \"langgraph-package-generator\"\nversion = \"0.1.0\"\ndescription = \"LangGraph-based generator: prompt -> structured JSON -> validate -> generate a pip-installable package\"\nrequires-python = \">=3.10\"\nreadme = \"README.md\"\nlicense = { text = \"MIT\" }\nauthors = [{ name = \"Theo Miller\" }]\ndependencies = [\n  \"langgraph>=0.2.0\",\n  \"pydantic>=2.6.0\",\n  \"python-dotenv>=1.0.0\",\n  \"langchain>=0.2.0\",\n  \"langchain-openai>=0.2.0\"\n]\n\n[project.optional-dependencies]\ndev = [\n  \"pytest>=8.0.0\",\n  \"ruff>=0.6.0\"\n]\n\n[tool.pytest.ini_options]\naddopts = \"-q\"\ntestpaths = [\"tests\"]\n\n[tool.ruff]\nline-length = 100\n\n[build-system]\nrequires = [\"setuptools>=68\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n",
  "app/main.py": "import argparse\nimport os\nfrom dotenv import load_dotenv\n\nfrom generator.graph import build_graph\n\n\ndef parse_args() -> argparse.Namespace:\n    p = argparse.ArgumentParser(description=\"Generate a pip-installable Python package using LangGraph.\")\n    p.add_argument(\"--out\", default=\"./out\", help=\"Output root directory\")\n    p.add_argument(\"--name\", default=\"greet_package\", help=\"Package name\")\n    p.add_argument(\n        \"--request\",\n        default=\"请生成一个最小可安装的 python 包，提供 greet(name: str) -> str，返回 'Hello, {name}!'，并包含测试、README、LICENSE、MANIFEST.in、setup.py。\",\n        help=\"User request to inject into prompt\",\n    )\n    return p.parse_args()\n\n\ndef main() -> None:\n    load_dotenv()\n\n    args = parse_args()\n    os.makedirs(args.out, exist_ok=True)\n\n    graph = build_graph()\n\n    result = graph.invoke(\n        {\n            \"user_input\": args.request,\n            \"output_root\": os.path.abspath(args.out),\n            \"package_name\": args.name,\n            \"revision_count\": 0,\n            \"last_error\": \"\",\n        }\n    )\n\n    print(result.get(\"response\", \"(no response)\"))\n\n\nif __name__ == \"__main__\":\n    main()\n",
  "generator/__init__.py": "\"\"\"LangGraph package generator.\"\"\"\n",
  "generator/config.py": "from __future__ import annotations\n\nimport os\nfrom pydantic import BaseModel\n\n\nclass Settings(BaseModel):\n    openai_api_key: str | None = os.getenv(\"OPENAI_API_KEY\")\n    openai_model: str = os.getenv(\"OPENAI_MODEL\", \"gpt-4.1-mini\")\n    max_plan_revisions: int = int(os.getenv(\"MAX_PLAN_REVISIONS\", \"3\"))\n\n\nsettings = Settings()\n",
  "generator/prompts.py": "from __future__ import annotations\n\nfrom datetime import datetime, timezone\n\n\nPROMPT_TEMPLATE = r\"\"\"\n<propmpt>\n\n\n<system>\n<!-- ① 角色定位 & 能力边界 -->\n你是高级软件工程师，负责python package的开发工作。\n总原则：\n1) 先澄清再行动：缺少关键输入就提问；不猜测。\n2) 证据优先：引用提供的上下文/检索结果/工具返回；区分事实与推断。\n3) 工具优先：遇到需要外部事实/计算/检索/系统状态，必须调用工具，不要编造。\n4) 输出可执行：给出可落地步骤、可验证结论与风险提示。\n5) 遵守安全与合规边界：{policy_brief}\n\n<!-- ② 核心任务指令 -->\n## Objective\n开发一个Python package，满足以下要求：\n1) 包含一个模块，提供一个函数 `greet(name: str) -> str\n2) 该包可以直接放入pip安装的格式，并且可以通过 `pip install .` 来安装\n3) 包含必要的文件，如 `setup.py` 和 `__init__.py`\n4) 提供一个简单的测试用例，验证 `greet` 函数的功能\n5） 包含一个README文件，说明如何安装和使用该包\n6） 包含一个LICENSE文件，说明该包的使用许可，建议使用MIT License\n7） 包含一个MANIFEST.in文件，确保所有必要的文件都被包含在包中\n8）该包放入git仓库，可以直接通过pip中加git仓库地址来安装\n\n<!-- ③ 工具定义 (Tool-use场景) -->\n## Available Tools\n- `search(query: str)` → Returns top-k web results. Use when: facts, recent events.\n- `code_exec(code: str, lang: str)` → Runs code, returns stdout/stderr. Use when: computation, data analysis.\n- `memory_retrieve(key: str)` → Fetches from long-term store. Use when: user history needed.\n\n<!-- ④ 思维框架 -->\n## Reasoning Protocol\nBefore responding, silently run:\n1. CLASSIFY: Is this [task_type_A | task_type_B | ambiguous]?\n2. PLAN: List 2-3 sub-steps needed.\n3. EXECUTE: Use tools if confidence < 0.85 or data > [CUTOFF].\n4. VERIFY: Does output satisfy the objective? If not, retry once.\n\n<!-- ⑤ 输出规范 -->\n## Output Format\n- Language: python package development\n- Structure:\n    - 输入一个json对象：\n        - key为这个package的文件名称，value为该文件的内容\n        - value的内容必须是字符串格式，且符合该文件的语法规范\n    - 不要输出任何其他不相关的内容\n\n\n<!-- ⑥ 约束 & 护栏 -->\n## Constraints\n- NEVER fabricate citations, URLs, or statistics.\n- If uncertain (confidence < 0.7), say \"I'm not sure, but…\" and offer to search.\n- Stay within [DOMAIN]; for out-of-scope queries, say: \"This is outside my scope. Try [RESOURCE].\"\n- Max tool calls per turn: 3. If more needed, ask user for permission.\n\n<!-- ⑦ 记忆 & 上下文注入 -->\n## Context\n- User profile: {user_name}, role={user_role}, preference={output_pref}\n- Session history summary: {memory_summary}  ← 压缩后注入，非原始对话\n- Current task state: {task_state_json}\n\n\n<!-- ⑧ 少样本示例 (Few-shot) -->\n## Examples\n    <example id=\"1\">\n        {{\n            \"setup.py\": \"from setuptools import setup, find_packages\\\\n\\\\nsetup(\\\\n    name='greet_package',\\\\n    version='0.1',\\\\n    packages=find_packages(),\\\\n    install_requires=[],\\\\n)\",\n            \"__init__.py\": \"def greet(name: str) -> str:\\\\n    return f'Hello, {{name}}!'\",\n            \"README.md\": \"# Greet Package\\\\n\\\\nThis package provides a simple greeting function.\\\\n\\\\n## Installation\\\\n\\\\n```bash\\\\npip install .\\\\n```\\\\n\\\\n## Usage\\\\n\\\\n```python\\\\nfrom greet_package import greet\\\\nprint(greet('World'))  # Output: Hello, World!\\\\n```\",\n            \"LICENSE\": \"MIT License\\\\n\\\\nCopyright (c) 2024 {user_name}\\\\n\\\\nPermission is hereby granted, free of charge, to any person obtaining a copy...\"\n        }}\n    </example>\n</system>\n\n\n<!-- 动态注入区域 (每轮更新) -->\n<context_window>\n  <timestamp>{ISO_8601}</timestamp>\n  <tools_results>{last_tool_output}</tools_results>\n  <remaining_budget>tokens_left={remaining} | iter_left={iter}</remaining_budget>\n</context_window>\n\n\n<user_message>\n{user_input}\n</user_message>\n\n</propmpt>\n\"\"\"\n\n\ndef render_prompt(\n    *,\n    user_input: str,\n    policy_brief: str,\n    user_name: str,\n    user_role: str,\n    output_pref: str,\n    memory_summary: str,\n    task_state_json: str,\n    last_tool_output: str,\n    remaining: int,\n    iter_left: int,\n) -> str:\n    iso = datetime.now(timezone.utc).isoformat()\n    return PROMPT_TEMPLATE.format(\n        policy_brief=policy_brief,\n        user_name=user_name,\n        user_role=user_role,\n        output_pref=output_pref,\n        memory_summary=memory_summary,\n        task_state_json=task_state_json,\n        ISO_8601=iso,\n        last_tool_output=last_tool_output,\n        remaining=remaining,\n        iter=iter_left,\n        user_input=user_input,\n    )\n",
  "generator/schema.py": "from __future__ import annotations\n\nfrom pydantic import BaseModel, Field\nfrom typing import Dict\n\n\nclass FileMap(BaseModel):\n    \"\"\"LLM 输出：一个文件路径到文件内容的映射。\"\"\"\n\n    files: Dict[str, str] = Field(..., description=\"key=filepath, value=file content\")\n",
  "generator/state.py": "from __future__ import annotations\n\nfrom typing import TypedDict, Optional\n\n\nclass GraphState(TypedDict, total=False):\n    # inputs\n    user_input: str\n    output_root: str\n    package_name: str\n\n    # planner\n    prompt_text: str\n    raw_json_text: str\n\n    # validator\n    files: dict[str, str]\n    last_error: str\n    revision_count: int\n\n    # executor\n    generated_dir: str\n    written_files: list[str]\n\n    # final\n    response: str\n",
  "generator/graph.py": "from __future__ import annotations\n\nfrom langgraph.graph import StateGraph, END\n\nfrom generator.state import GraphState\nfrom generator.nodes.planner import planner_node\nfrom generator.nodes.validator import validator_node\nfrom generator.nodes.executor import executor_node\nfrom generator.nodes.finalizer import finalizer_node\nfrom generator.config import settings\n\n\nPLANNER = \"planner\"\nVALIDATOR = \"validator\"\nEXECUTOR = \"executor\"\nFINALIZER = \"finalizer\"\n\n\ndef _route_after_validate(state: GraphState) -> str:\n    err = state.get(\"last_error\", \"\")\n    rev = int(state.get(\"revision_count\", 0))\n\n    if not err:\n        return EXECUTOR\n\n    if rev < settings.max_plan_revisions:\n        return PLANNER\n\n    return FINALIZER\n\n\ndef build_graph():\n    g = StateGraph(GraphState)\n\n    g.add_node(PLANNER, planner_node)\n    g.add_node(VALIDATOR, validator_node)\n    g.add_node(EXECUTOR, executor_node)\n    g.add_node(FINALIZER, finalizer_node)\n\n    g.set_entry_point(PLANNER)\n    g.add_edge(PLANNER, VALIDATOR)\n\n    g.add_conditional_edges(\n        VALIDATOR,\n        _route_after_validate,\n        {EXECUTOR: EXECUTOR, PLANNER: PLANNER, FINALIZER: FINALIZER},\n    )\n\n    g.add_edge(EXECUTOR, FINALIZER)\n    g.add_edge(FINALIZER, END)\n\n    return g.compile()\n",
  "generator/nodes/__init__.py": "\"\"\"Graph nodes.\"\"\"\n",
  "generator/nodes/planner.py": "from __future__ import annotations\n\nimport json\n\nfrom langchain_openai import ChatOpenAI\nfrom langchain.schema import HumanMessage\n\nfrom generator.config import settings\nfrom generator.prompts import render_prompt\nfrom generator.state import GraphState\n\n\n# 这里是一个简化的 policy brief（你也可以在调用时动态注入更完整的规则）\n_POLICY_BRIEF = \"遵守软件工程与安全最佳实践；不得输出危险指令；仅生成与任务相关的文件内容。\"\n\n\ndef _make_task_state_json(state: GraphState) -> str:\n    safe = {\n        \"package_name\": state.get(\"package_name\"),\n        \"output_root\": state.get(\"output_root\"),\n        \"revision_count\": state.get(\"revision_count\", 0),\n        \"last_error\": state.get(\"last_error\", \"\"),\n    }\n    return json.dumps(safe, ensure_ascii=False)\n\n\ndef planner_node(state: GraphState) -> GraphState:\n    user_input = state[\"user_input\"]\n    revision_count = int(state.get(\"revision_count\", 0))\n    last_error = state.get(\"last_error\", \"\")\n\n    # 当校验失败时，把错误回喂给 user_input 以促使模型修正输出 JSON\n    if last_error:\n        user_input = (\n            f\"{user_input}\\n\\n\"\n            f\"上次输出未通过校验，错误如下：{last_error}\\n\"\n            f\"请修正并只输出一个 JSON 对象（key=文件路径, value=文件内容字符串）。\"\n        )\n\n    prompt_text = render_prompt(\n        user_input=user_input,\n        policy_brief=_POLICY_BRIEF,\n        user_name=\"Theo Miller\",\n        user_role=\"engineer\",\n        output_pref=\"json-filemap-only\",\n        memory_summary=\"\",\n        task_state_json=_make_task_state_json(state),\n        last_tool_output=\"\",\n        remaining=0,\n        iter_left=max(0, 3 - revision_count),\n    )\n\n    llm = ChatOpenAI(\n        model=settings.openai_model,\n        api_key=settings.openai_api_key,\n        temperature=0.2,\n    )\n\n    # 关键点：把整个 XML prompt 当作 HumanMessage 发给模型\n    # 因为模板已经在 system 区块里规定“只输出 JSON”。\n    resp = llm.invoke([HumanMessage(content=prompt_text)])\n\n    return {\n        **state,\n        \"prompt_text\": prompt_text,\n        \"raw_json_text\": resp.content,\n        \"revision_count\": revision_count + (1 if last_error else 0),\n    }\n",
  "generator/nodes/validator.py": "from __future__ import annotations\n\nimport json\nfrom typing import Any\n\nfrom generator.state import GraphState\nfrom generator.runtime.sanitize import validate_file_map\n\n\ndef _strip_fences(text: str) -> str:\n    t = text.strip()\n    if t.startswith(\"```\"):\n        # 简易处理：去掉开头/结尾 fence\n        t = t.strip(\"`\")\n        # 可能是 json\\n...\n        if t.startswith(\"json\\n\"):\n            t = t[5:]\n        t = t.strip()\n    return t\n\n\ndef validator_node(state: GraphState) -> GraphState:\n    raw = state.get(\"raw_json_text\", \"\")\n\n    try:\n        raw = _strip_fences(raw)\n        parsed: Any = json.loads(raw)\n        if not isinstance(parsed, dict):\n            raise ValueError(\"Top-level JSON must be an object mapping file paths to string contents\")\n\n        # 强约束：所有 value 必须是字符串\n        files: dict[str, str] = {}\n        for k, v in parsed.items():\n            if not isinstance(k, str):\n                raise ValueError(\"All keys must be strings (file paths)\")\n            if not isinstance(v, str):\n                raise ValueError(f\"File content for {k} must be a string\")\n            files[k] = v\n\n        # 基本安全检查 + 必要文件检查\n        validate_file_map(files, package_name=state.get(\"package_name\", \"greet_package\"))\n\n        return {**state, \"files\": files, \"last_error\": \"\"}\n\n    except Exception as e:\n        return {**state, \"last_error\": f\"{type(e).__name__}: {e}\"}\n",
  "generator/nodes/executor.py": "from __future__ import annotations\n\nimport os\n\nfrom generator.state import GraphState\nfrom generator.runtime.fs import write_files\n\n\ndef executor_node(state: GraphState) -> GraphState:\n    files = state.get(\"files\", {})\n    output_root = state[\"output_root\"]\n    package_name = state.get(\"package_name\", \"greet_package\")\n\n    target_dir = os.path.join(output_root, package_name)\n    written = write_files(target_dir, files)\n\n    return {\n        **state,\n        \"generated_dir\": target_dir,\n        \"written_files\": written,\n    }\n",
  "generator/nodes/finalizer.py": "from __future__ import annotations\n\nfrom generator.state import GraphState\n\n\ndef finalizer_node(state: GraphState) -> GraphState:\n    err = state.get(\"last_error\", \"\")\n    if err:\n        return {**state, \"response\": f\"FAILED: {err}\"}\n\n    out_dir = state.get(\"generated_dir\", \"\")\n    written = state.get(\"written_files\", [])\n\n    msg = [\"OK: package generated\", f\"dir: {out_dir}\", f\"files: {len(written)}\"]\n    # 列前 20 个，避免输出过长\n    for p in written[:20]:\n        msg.append(f\"- {p}\")\n    if len(written) > 20:\n        msg.append(f\"... ({len(written) - 20} more)\")\n\n    return {**state, \"response\": \"\\n\".join(msg)}\n",
  "generator/runtime/__init__.py": "\"\"\"Runtime helpers for safe filesystem writes.\"\"\"\n",
  "generator/runtime/fs.py": "from __future__ import annotations\n\nimport os\n\nfrom generator.runtime.sanitize import safe_join\n\n\ndef write_files(base_dir: str, files: dict[str, str]) -> list[str]:\n    \"\"\"Write file map to disk under base_dir. Returns list of written paths.\"\"\"\n    os.makedirs(base_dir, exist_ok=True)\n    written: list[str] = []\n\n    for rel_path, content in files.items():\n        abs_path = safe_join(base_dir, rel_path)\n        parent = os.path.dirname(abs_path)\n        os.makedirs(parent, exist_ok=True)\n        with open(abs_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n        written.append(abs_path)\n\n    return written\n",
  "generator/runtime/sanitize.py": "from __future__ import annotations\n\nimport os\n\n\n_REQUIRED_FILES = {\n    \"setup.py\",\n    \"MANIFEST.in\",\n    \"README.md\",\n    \"LICENSE\",\n}\n\n\ndef safe_join(base_dir: str, rel_path: str) -> str:\n    \"\"\"Prevent path traversal; return absolute safe path.\"\"\"\n    base_abs = os.path.abspath(base_dir)\n    target_abs = os.path.abspath(os.path.join(base_abs, rel_path))\n\n    if target_abs == base_abs:\n        raise ValueError(\"Invalid path: points to base directory\")\n\n    # Must stay inside base_dir\n    if not (target_abs.startswith(base_abs + os.sep)):\n        raise ValueError(f\"Path traversal detected: {rel_path}\")\n\n    return target_abs\n\n\ndef validate_file_map(files: dict[str, str], package_name: str) -> None:\n    \"\"\"Basic structural checks for a pip-installable package.\"\"\"\n    missing = [f for f in _REQUIRED_FILES if f not in files]\n    if missing:\n        raise ValueError(f\"Missing required top-level files: {missing}\")\n\n    # Must include package module init\n    init_candidates = [\n        f\"{package_name}/__init__.py\",\n        f\"src/{package_name}/__init__.py\",\n    ]\n    if not any(p in files for p in init_candidates):\n        raise ValueError(\n            \"Missing __init__.py. Expected one of: \" + \", \".join(init_candidates)\n        )\n\n    # Minimal greet function presence check (soft)\n    init_path = next((p for p in init_candidates if p in files), None)\n    if init_path and \"greet\" not in files[init_path]:\n        raise ValueError(\"__init__.py does not appear to define or export greet\")\n\n    # Prevent absolute paths\n    for path in files.keys():\n        if os.path.isabs(path):\n            raise ValueError(f\"Absolute paths are not allowed: {path}\")\n        if \"\\x00\" in path:\n            raise ValueError(\"NUL byte in path\")\n",
  "tests/test_validator.py": "from generator.runtime.sanitize import validate_file_map\n\n\ndef test_validate_file_map_ok():\n    files = {\n        \"setup.py\": \"print('x')\\n\",\n        \"MANIFEST.in\": \"include README.md\\n\",\n        \"README.md\": \"# hi\\n\",\n        \"LICENSE\": \"MIT\\n\",\n        \"src/greet_package/__init__.py\": \"def greet(name: str) -> str:\\n    return f'Hello, {name}!'\\n\",\n    }\n    validate_file_map(files, package_name=\"greet_package\")\n",
  "generator/nodes/planner_fallback_package.py": "from __future__ import annotations\n\n\"\"\"可选：当你不想调用 LLM 时，提供一个确定性的模板输出。\n\n你可以在 planner_node 中检测 OPENAI_API_KEY 是否存在，若不存在则返回这个模板。\n\"\"\"\n\n\ndef deterministic_file_map(package_name: str) -> dict[str, str]:\n    pkg = package_name\n    return {\n        \"README.md\": f\"# {pkg}\\n\\nA tiny package that provides greet(name) -> str.\\n\\n## Install\\n\\n```bash\\npip install .\\n```\\n\\n## Usage\\n\\n```python\\nfrom {pkg} import greet\\nprint(greet('World'))\\n```\\n\",\n        \"LICENSE\": \"MIT License\\n\\nCopyright (c) 2026\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy...\\n\",\n        \"MANIFEST.in\": \"include README.md\\ninclude LICENSE\\ninclude MANIFEST.in\\nrecursive-include src *.py\\nrecursive-include tests *.py\\n\",\n        \"setup.py\": (\n            \"from setuptools import setup, find_packages\\n\\n\"\n            \"setup(\\n\"\n            f\"    name='{pkg}',\\n\"\n            \"    version='0.1.0',\\n\"\n            \"    package_dir={'': 'src'},\\n\"\n            \"    packages=find_packages(where='src'),\\n\"\n            \"    include_package_data=True,\\n\"\n            \"    python_requires='>=3.10',\\n\"\n            \")\\n\"\n        ),\n        f\"src/{pkg}/__init__.py\": (\n            \"def greet(name: str) -> str:\\n\"\n            \"    return f'Hello, {name}!'\\n\"\n        ),\n        \"tests/test_greet.py\": (\n            f\"from {pkg} import greet\\n\\n\"\n            \"def test_greet():\\n\"\n            \"    assert greet('World') == 'Hello, World!'\\n\"\n        ),\n    }\n",
  "example_generated_package/README.md": "# Example generated package output (reference)\n\n下面这些文件不会被本生成器运行时写出；它只是一个参考，展示 LLM 最终应该生成的目标包结构。\n\n目标包结构：\n\n```\ngreet_package/\n  setup.py\n  MANIFEST.in\n  README.md\n  LICENSE\n  src/\n    greet_package/\n      __init__.py\n  tests/\n    test_greet.py\n```\n\n你实际运行生成器后，会在 `./out/<package_name>/` 看到类似结构。\n",
  "example_generated_package/setup.py": "from setuptools import setup, find_packages\n\nsetup(\n    name=\"greet_package\",\n    version=\"0.1.0\",\n    package_dir={\"\": \"src\"},\n    packages=find_packages(where=\"src\"),\n    include_package_data=True,\n    python_requires=\">=3.10\",\n)\n",
  "example_generated_package/MANIFEST.in": "include README.md\ninclude LICENSE\ninclude MANIFEST.in\nrecursive-include src *.py\nrecursive-include tests *.py\n",
  "example_generated_package/LICENSE": "MIT License\n\nCopyright (c) 2026\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n",
  "example_generated_package/src/greet_package/__init__.py": "def greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n",
  "example_generated_package/tests/test_greet.py": "from greet_package import greet\n\n\ndef test_greet():\n    assert greet(\"World\") == \"Hello, World!\"\n"
}
